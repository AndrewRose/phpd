#!/usr/bin/php -q
<?php
/* 
  phpd Copyright (C) 2007 Andrew Rose
  rose.andrew@gmail.com
  http://andrewrose.co.uk
  http://andrew-rose.blogspot.com

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

define('INICONF', 'phpd.ini');

set_time_limit(0);
declare(ticks = 1);

require_once('../../Aplc.php');
Aplc::setupAutoloader();

require_once('test.php');

class Phpd_Child extends Aplc_Daemon_Child
{
	public $server = "phpd/1.0";
	public $protocol = "HTTP/1.1";
	public $socket;

	public $class = FALSE;
	public $headers = array();

	public function start()
	{
		$this->class = new test;

		while(1)
		{
			/* we silence this as it will fall over when we set nonblock on the sock during shutdown */
			if(($c = @socket_accept($this->socket)) !== FALSE)
			{
				$request = socket_read($c, 1024000);
				$this->dissolveRequest($request);
				//echo $request;

//				$data = '<form action="someaction.php" method="post"><input type="text" name="testvar"><input type="checkbox" name="testscheck"><input type="submit"></form>hello world! from: '.$this->pid."\r\n";
//				$data = gzdeflate($data);

				
				/* this would be in a module/init */
				if(isset($_COOKIE['PHPSESSID']))
				{
					session_id($_COOKIE['PHPSESSID']);
				}
				else
				{
					$sessid = md5(rand(1, 1000000));
					$this->addHeader('Set-Cookie: PHPSESSID='.$sessid);
					session_id($sessid);
				}
				@session_start();
				/* */

				/* main script execution */
				$data =	$this->class->main($this);
				/* */

				/* this belongs in a module/deinit */
				session_write_close();
				unset($_COOKIE);
				/* */

//				$headers = $this->headers(200, "OK", strlen($data), "Content-Encoding: deflate\r\n");
				$headers = $this->headers(200, "OK", strlen($data));
// messy I know
$this->headers = array();

				$response = (string)$headers.$data;

				if(socket_write($c, $response, strlen($response)) != strlen($response))
				{
					echo "Failed to write response...\n";
				}

				socket_close($c);
			}

			if($this->shutdown)
			{
				return;
			}
		}
	}

	/* http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html */
	public function dissolveRequest($request)
	{
		$_COOKIE = array();
		$request = trim($request);
		$headers = explode("\r\n", $request);

		$headers = array_reverse($headers);
		$request = array_pop($headers);
		$parts = explode(' ', $request);

		switch($parts[0])
		{
			case 'GET':
				$method = 'GET';
			break;
			case 'POST':
				$method = 'POST';
			break;
			default:
				return FALSE;
			break;
		}

		$uri = $parts[1];
		$version = $parts[2];		

		foreach($headers as $header)
		{
			list($header, $value) = explode(':', $header);
			switch(trim($header))
			{
				case 'Cookie':
				{
					$vars = explode('&', $value);
					foreach($vars as $var)
					{
						list($k, $v) = explode('=', $value);
						$_COOKIE[trim($k)] = trim($v);
					}
				}
				break;
			}
		}
	}

	public function addHeader($header)
	{
		$this->headers[] = $header;
	}

	public function headers($status, $title, $length=0, $extra='', $mime='text/html')
	{
		$headers = $this->protocol.' '.$status.' '.$title."\r\n";
		$headers .= 'Server: '.$this->server."\r\n";
		$headers .= 'Date: '.date('D, d M Y H:i:s e', time())."\r\n";
		foreach($this->headers as $header)
		{
			$headers .= $header."\r\n";
		}
		if($extra)
		{
			$headers .= $extra;
		}
		$headers .= 'Content-Type: '.$mime."\r\n";
		$headers .= 'Content-Length: '.$length."\r\n";
		$headers .= 'Connection: close'."\r\n";
		return $headers . "\r\n";
	}

	public function reload()
	{
		$this->class = new test;
	}

	public function shutdown()
	{
	}
}

class Phpd extends Aplc_Daemon
{
	public $socket;

	public function start()
	{
		if(!($this->socket = @socket_create(AF_INET, SOCK_STREAM, 0)))
		{
			exit("Failed to create socket!\n");
		}

		if(!@socket_bind($this->socket, $this->reg->get('server.address'), $this->reg->get('server.port')))
		{
			exit("Unable to bind to socket!\n");
		}

		if(!@socket_listen($this->socket, $this->reg->get('server.backLog')))
		{
			exit("Unable to listen on socket!\n");
		}

		$phpd = new Phpd_Child;
		for($i=$this->reg->get('server.maxChildren');$i;$i--)
		{
			$phpd->socket = $this->socket;
			$this->child($phpd);
		}

		unset($phpd);

		while(1)
		{
			if($this->shutdown)
			{
				return TRUE;
			}
			sleep(1);
		}
	}

	public function reload()
	{
	}

	/* Because we block on the main socket we need to "poke" the child processes
	   by creating new connections so they shutdown */
	public function shutdown()
	{
		$this->shutdown = TRUE;

		socket_set_nonblock($this->socket);

		/* really shouldn't need to do this but some wierd bug requires it.. */
		sleep(1);
		@fsockopen($this->address, $this->port, $errno, $errstr, 2);

		$this->waitChildren();

		socket_close($this->socket);

		return;
	}
}

$phpd = new phpd;
$phpd->main();
