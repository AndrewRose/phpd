#!/usr/bin/php -q
<?php
/* 
  phpd Copyright (C) 2007, 2008 Andrew Rose
  rose.andrew@gmail.com
  http://andrewrose.co.uk
  http://andrew-rose.blogspot.com

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

define('INICONF', 'phpd.ini');

set_time_limit(0);
declare(ticks = 1);

require_once('transport/stream.php');
require_once('transport/socket.php');

require_once('/usr/lib/aplc/Aplc.php');
Aplc::setupAutoloader();

class Phpd_Autoloader implements Aplc_Autoloader
{
	public function register()
	{
		spl_autoload_register(array($this, 'loader'));
	}

	public function loader($className)
	{
		$file = 'modules/' . strtolower(str_replace('_', '', str_replace('Phpd_Module', '', $className))) . '.php';
		if (file_exists($file))
		{
			require_once $file;
		}
	}
}

interface Phpd_Module
{
	public function init(Phpd_Child $o);
	public function request(Phpd_Child $o);
	public function response(Phpd_Child $o);
	public function cleanup(Phpd_Child $o);
	public function deinit(Phpd_Child $o);
}

interface Phpd_Transport
{
	public function init(Phpd $o);
	public function request(Phpd_Child $o);
	public function response(Phpd_Child $o);
	public function deinit(Phpd $o);
}

class Phpd_Child extends Aplc_Daemon_Child
{
	public $server = "phpd/1.0";
	public $protocol = "HTTP/1.1";
	public $transport;
	public $request;
	public $response;
	public $headers = array();
	public $modules = array();
	public $data = '';

	public $status = 200;
	public $statusCodes = array(
		200 => 'OK',
		500 => 'Internal Server Error',
		501 => 'Not Implemented',
		505 => 'HTTP Version Not Supported'
	);

	public function start()
	{
		pcntl_signal(SIGALRM, array(&$this, "sigAlarm"));
		pcntl_alarm(5);

		if(!$this->pokeModules('init'))
		{
			$this->log->write('Unable to init modules');
			sleep(5);
			exit();
		}

		while(1)
		{
			if($this->transport->request($this))
			{
				if($this->pokeModules('request'))
				{
					if(!$this->pokeModules('response'))
					{
						if($this->status == 200)
						{
							$this->status = 500;
						}
					}
				}
				else
				{
					if($this->status == 200)
					{
						$this->status = 500;
					}
				}

				if($this->status!= 200)
				{
					$this->data = $this->statusCodes[$this->status];
				}

				$headers = $this->headers($this->status, $this->statusCodes[$this->status], strlen($this->data));
				$this->response = (string)$headers.$this->data;

				$this->transport->response($this);

				$this->pokeModules('cleanup'); // module cleanup
				$this->cleanup(); // phpd cleanup

				if($this->shutdown)
				{
					return;
				}
			}

			if($this->shutdown)
			{
				return;
			}
		}
	}

	public function pokeModules($action)
	{
		$failure = FALSE;

		if($action == 'deinit')
		{
			$this->modules = array_reverse($this->modules, TRUE);
		}

		try
		{
			foreach($this->modules as $name => $module)
			{
				if(!$module->$action($this))
				{
					$this->log->write('Failed to poke module: '.$name.' with action: '.$action);
					sleep(1);
					return FALSE;
				}
			}
		}
                catch(Aplc_Exception $e)
                {
                        echo $e->getMessage();
                        while(1)
                        {
                                if($this->shutdown)
                                {
                                        return;
                                }
                                sleep(1);
                        }
                }

		return TRUE;
	}

	public function cleanup()
	{
		$this->headers = array();
		$this->request = '';
		$this->response = '';
		$this->data = '';
		$this->status = 200;
	}

	public function header($header)
	{
		$this->headers[] = $header;
	}

	public function headers($status, $title, $length=0, $mime='text/html')
	{
		$headers = $this->protocol.' '.$status.' '.$title."\r\n";
		$headers .= 'Server: '.$this->server."\r\n";
		$headers .= 'Date: '.date('D, d M Y H:i:s e', time())."\r\n";
		foreach($this->headers as $header)
		{
			$headers .= $header."\r\n";
		}
		$headers .= 'Content-Type: '.$mime."\r\n";
		$headers .= 'Content-Length: '.$length."\r\n";
		$headers .= 'Connection: close'."\r\n";
		return $headers . "\r\n";
	}

	public function reload()
	{
		$this->initRegistry();
	}

	public function shutdown()
	{
		$this->pokeModules('deinit');
	}

	public function sigAlarm()
	{
		pcntl_alarm(5);
	}
}

class Phpd extends Aplc_Daemon
{
	public $transport;

	public function start()
	{
		if(!$this->reg->exists('_phpd.transport'))
		{
			exit("Unable to determine transport!\n");
		}
		else
		{
			$class = 'Phpd_Transport_'.$this->reg->get('_phpd.transport');
			$this->transport = new $class;
		}

		$this->initLog();
		$this->childRespawn = TRUE;

		if(!$this->transport->init($this))
		{
			exit("Unable to start socket server\n");
		}

		$phpd = new Phpd_Child;
		$phpd->transport = $this->transport;

		if($this->reg->exists('_phpd.moduleLocation,_phpd.module'))
		{
			foreach($this->reg->get('_phpd.module') as $module => $discard)
			{
				$class = 'Phpd_Module_'.$module;
				$phpd->modules[$module] = new $class;
			}
		}

		/* override _aplc.Daemon.maxFork with our preFork setting */
		$this->reg->set('_aplc.Daemon.maxFork', $this->reg->getOrSet('_phpd.preFork', FALSE, 1));

		while(1)
		{
			if($this->shutdown)
			{
				return TRUE;
			}
			$this->child($phpd);
		}

		unset($phpd);
	}

	public function reload()
	{
		$this->initRegistry();
	}

	public function shutdown()
	{
		$this->waitChildren();
		$this->transport->deinit($this);
	}
}

$moduleLoader = new Phpd_Autoloader;
$moduleLoader->register();

$phpd = new phpd;
$phpd->main();
