#!/usr/bin/php -q
<?php
/* 
  phpd Copyright (C) 2007 Andrew Rose
  rose.andrew@gmail.com
  http://andrewrose.co.uk
  http://andrew-rose.blogspot.com

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

define('INICONF', 'phpd.ini');

set_time_limit(0);
declare(ticks = 1);

require_once('/usr/lib/aplc/Aplc.php');
Aplc::setupAutoloader();

require_once('test.php');
require_once('modules/request.php');
require_once('modules/session.php');


interface Phpd_Module
{
	public function init(Phpd_Child $o);
	public function deinit(Phpd_Child $o);
}

class Phpd_Child extends Aplc_Daemon_Child
{
	public $modules = array();

	public $server = "phpd/1.0";
	public $protocol = "HTTP/1.1";
	public $socket;

	public $class = FALSE;
	public $headers = array();

	public function start()
	{
		$this->class = new test;

		while(1)
		{
			/* we silence this as it will fall over when we set nonblock on the sock during shutdown */
			if(($c = @socket_accept($this->socket)) !== FALSE)
			{
				$this->request = socket_read($c, 1024000);
	
				$this->initModules();

				/* main script execution */
				$data =	$this->class->main($this);
				/* */

				$headers = $this->headers(200, "OK", strlen($data));

				$response = (string)$headers.$data;

				if(socket_write($c, $response, strlen($response)) != strlen($response))
				{
					echo "Failed to write response...\n";
				}

				socket_close($c);

				$this->deinitModules();
				$this->cleanup();
			}

			if($this->shutdown)
			{
				return;
			}
		}
	}

	public function initModules()
	{
		foreach($this->modules as $module)
		{
			$module->init($this);
		}
	}

	public function deinitModules()
	{
		foreach($this->modules as $module)
		{
			$module->deinit($this);
		}
	}

	public function cleanup()
	{
		$this->headers = array();
	}

	public function header($header)
	{
		$this->headers[] = $header;
	}

	public function headers($status, $title, $length=0, $extra='', $mime='text/html')
	{
		$headers = $this->protocol.' '.$status.' '.$title."\r\n";
		$headers .= 'Server: '.$this->server."\r\n";
		$headers .= 'Date: '.date('D, d M Y H:i:s e', time())."\r\n";
		foreach($this->headers as $header)
		{
			$headers .= $header."\r\n";
		}
		if($extra)
		{
			$headers .= $extra;
		}
		$headers .= 'Content-Type: '.$mime."\r\n";
		$headers .= 'Content-Length: '.$length."\r\n";
		$headers .= 'Connection: close'."\r\n";
		return $headers . "\r\n";
	}

	public function reload()
	{
		$this->class = new test;
	}

	public function shutdown()
	{
	}
}

class Phpd extends Aplc_Daemon
{
	public $socket;

	public function start()
	{
		if(!($this->socket = @socket_create(AF_INET, SOCK_STREAM, 0)))
		{
			exit("Failed to create socket!\n");
		}

		if(!@socket_bind($this->socket, $this->reg->get('server.address'), $this->reg->get('server.port')))
		{
			$error = socket_last_error($this->socket);
			$error = socket_strerror($error);
			exit('Unable to bind to socket: '.$error."\n");
		}

		if(!@socket_listen($this->socket, $this->reg->get('server.backLog')))
		{
			exit("Unable to listen on socket!\n");
		}

		$phpd = new Phpd_Child;
		$phpd->modules[] = new Phpd_Module_Request;
		$phpd->modules[] = new Phpd_Module_Session;

		for($i=$this->reg->get('server.maxChildren');$i;$i--)
		{
			$phpd->socket = $this->socket;
			$this->child($phpd);
		}

		unset($phpd);

		while(1)
		{
			if($this->shutdown)
			{
				return TRUE;
			}
			sleep(1);
		}
	}

	public function reload()
	{
	}

	/* Because we block on the main socket we need to "poke" the child processes
	   by creating new connections so they shutdown */
	public function shutdown()
	{
		$this->shutdown = TRUE;

		socket_set_nonblock($this->socket);

		/* really shouldn't need to do this but some wierd bug requires it.. */
		sleep(1);
		@fsockopen($this->address, $this->port, $errno, $errstr, 2);

		$this->waitChildren();

		socket_close($this->socket);

		return;
	}
}

$phpd = new phpd;
$phpd->main();
