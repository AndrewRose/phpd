#!/usr/bin/php -q
<?php
/* 
  phpd Copyright (C) 2007 Andrew Rose
  rose.andrew@gmail.com
  http://andrewrose.co.uk
  http://andrew-rose.blogspot.com

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

define('INICONF', 'phpd.ini');

set_time_limit(0);
declare(ticks = 1);

//require_once('/usr/lib/aplc/Aplc.php');
require_once('../../Aplc.php');
Aplc::setupAutoloader();

interface Phpd_Application
{
	public function init(Phpd_Child $o);
	public function response(Phpd_Child $o);
	public function cleanup(Phpd_Child $o);
	public function deinit(Phpd_Child $o);
}

interface Phpd_Module
{
	public function init(Phpd_Child $o);
	public function request(Phpd_Child $o);
	public function response(Phpd_Child $o);
	public function cleanup(Phpd_Child $o);
	public function deinit(Phpd_Child $o);
}

class Phpd_Autoloader implements Aplc_Autoloader
{
	public function register()
	{
		spl_autoload_register(array($this, 'loader'));
	}

	public function loader($className)
	{
		$file = 'modules/' . strtolower(str_replace('_', '', str_replace('Phpd_Module', '', $className))) . '.php';
		if (file_exists($file))
		{
			require_once $file;
		}
	}
}

class Phpd_Child extends Aplc_Daemon_Child
{
	public $server = "phpd/1.0";
	public $protocol = "HTTP/1.1";
	public $socket;
	public $headers = array();
	public $modules = array();
	public $data = '';
	public $application = FALSE;

	public function start()
	{
		$this->initModules();
		$this->application->init($this);

		while(1)
		{
			if(($c = @stream_socket_accept($this->socket)) !== FALSE)
			{
				if($this->reg->true('_phpd.ssl.on'))
				{

/*
This blocking around the crypto enabler is to solve this bug (man it's a nasty fix, which only IE seems to cause):
Warning: fwrite(): SSL operation failed with code 1. OpenSSL Error messages:
error:140D00CF:SSL routines:func(208):reason(207) in /home/httpd/html/aplc/aplc-libs/Aplc/phpd/phpd on line 107

Update.. the blocking actions seem to break ssl for firefox :/ ug

*/
//stream_set_blocking($c, TRUE);
					if(stream_socket_enable_crypto($c, TRUE, STREAM_CRYPTO_METHOD_SSLv23_SERVER) === FALSE)
					{
						continue;
					}
//stream_set_blocking($c, FALSE);
				}

				$this->request = fread($c, $this->reg->get('_phpd.requestLimit'));

				$this->requestModules();

				/* main application entry point */
				$this->data = $this->application->response($this);
				/* */

				$this->responseModules();

				//$this->data = substr($this->data, 1, 150);

				$headers = $this->headers(200, "OK", strlen($this->data));

				$response = (string)$headers.$this->data;

				if(@fwrite($c, $response) == FALSE)
				{
					$this->log->write('Failed to write response to socket.  This is most likely a problem neogotiating an IE connection in SSL mode.');
				}

				stream_socket_shutdown($c, STREAM_SHUT_RDWR);

				$this->application->cleanup($this);
				$this->cleanupModules();
				$this->cleanup();
			}
			else
			{
				usleep($this->reg->getOrSet('_phpd.eventLoopDelay', FALSE, 500000));
			}

			if($this->shutdown)
			{
				return;
			}
		}
	}

	public function initModules()
	{
		try
		{
			foreach($this->modules as $module)
			{
				$module->init($this);
			}
		}
		catch(Aplc_Exception $e)
		{
			echo $e->getMessage();
			while(1)
			{
				if($this->shutdown)
				{
					return;
				}
				sleep(1);
			}
		}
	}

	public function requestModules()
	{
		foreach($this->modules as $module)
		{
			$module->request($this);
		}
	}

	public function responseModules()
	{
		foreach($this->modules as $module)
		{
			$module->response($this);
		}
	}

	public function cleanupModules()
	{
		foreach($this->modules as $module)
		{
			$module->cleanup($this);
		}
	}

	public function deinitModules()
	{
		foreach($this->modules as $module)
		{
			$module->deinit($this);
		}
	}

	public function cleanup()
	{
		$this->headers = array();
	}

	public function header($header)
	{
		$this->headers[] = $header;
	}

	public function headers($status, $title, $length=0, $extra='', $mime='text/html')
	{
		$headers = $this->protocol.' '.$status.' '.$title."\r\n";
		$headers .= 'Server: '.$this->server."\r\n";
		$headers .= 'Date: '.date('D, d M Y H:i:s e', time())."\r\n";
		foreach($this->headers as $header)
		{
			$headers .= $header."\r\n";
		}
		if($extra)
		{
			$headers .= $extra;
		}
		$headers .= 'Content-Type: '.$mime."\r\n";
		$headers .= 'Content-Length: '.$length."\r\n";
		$headers .= 'Connection: close'."\r\n";
		return $headers . "\r\n";
	}

	public function reload()
	{
		$this->initRegistry();
	}

	public function shutdown()
	{
		$this->application->deinit($this);
		$this->deinitModules();
	}
}

class Phpd extends Aplc_Daemon
{
	public $socket;

	public function start()
	{
		if(!$this->reg->exists('_phpd.application'))
		{
			exit("Unable to determine application!\n");
		}

		if(!file_exists($this->reg->get('_phpd.application').'/entrypoint.php'))
		{
			exit("Unable to locate application entrypoint.\n");
		}
		else
		{
			$class = $this->reg->get('_phpd.application');
			require_once($class.'/entrypoint.php');
			$application = new $class;
		}

		$this->initLog();
		$this->childRespawn = TRUE;

		$context = stream_context_create();

		if($this->reg->true('_phpd.ssl.on'))
		{
			stream_context_set_option($context, 'ssl', 'local_cert',$this->reg->get('_phpd.ssl.local_cert'));
			stream_context_set_option($context, 'ssl', 'passphrase', $this->reg->get('_phpd.ssl.passphrase'));

			if($this->reg->true('_phpd.ssl.allow_self_signed'))
			{
				stream_context_set_option($context, 'ssl', 'allow_self_signed', true);
			}
			if($this->reg->true('_phpd.ssl.verify_peer'))
			{
				stream_context_set_option($context, 'ssl', 'verify_peer', true);
			}

			$this->reg->set('_phpd.port', $this->reg->getOrSet('_phpd.ssl.port', '_phpd.port')); 
		}

		$this->socket = stream_socket_server('tcp://'.$this->reg->get('_phpd.address').':'.$this->reg->get('_phpd.port'), $errno, $errstr, STREAM_SERVER_BIND|STREAM_SERVER_LISTEN, $context);

/* would be great if this worked.. maybe we wouldn't lag so much on the per connection basis
		stream_set_blocking($this->socket, 1);
		if($this->reg->true('_phpd.ssl.on'))
		{
			if(stream_socket_enable_crypto($this->socket, TRUE, STREAM_CRYPTO_METHOD_SSLv23_SERVER) == FALSE)
			{
				$this->log->write('Failed to enable cryto for SSL session.');
			}
		}
*/
		/* if only we could catch a signal when a socket did block... */
		stream_set_blocking($this->socket, 0);

		$phpd = new Phpd_Child;
		$phpd->application = $application;
		$phpd->socket = $this->socket;

		if($this->reg->exists('_phpd.moduleLocation,_phpd.module'))
		{
			foreach($this->reg->get('_phpd.module') as $module => $discard)
			{
				$class = 'Phpd_Module_'.$module;
				$phpd->modules[] = new $class;
			}
		}

		/* override _aplc.Daemon.maxFork with our preFork setting */
		$this->reg->set('_aplc.Daemon.maxFork', $this->reg->getOrSet('_phpd.preFork', FALSE, 1));

		while(1)
		{
			if($this->shutdown)
			{
				return TRUE;
			}
			$this->child($phpd);
		}

		unset($phpd);
		unset($application);

	}

	public function reload()
	{
		$this->initRegistry();
	}

	public function shutdown()
	{
		$this->waitChildren();
		stream_socket_shutdown($this->socket, STREAM_SHUT_RDWR);
	}
}

$moduleLoader = new Phpd_Autoloader;
$moduleLoader->register();

$phpd = new phpd;
$phpd->main();
